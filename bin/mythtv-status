#!/usr/bin/perl -w
# Copyright (c) 2007 Andrew Ruthven <andrew@etc.gen.nz>
# This code is hereby licensed for public consumption under the GNU GPL v2.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Display the current status of a MythTV system.

use LWP::Simple;
use XML::LibXML;
use Date::Manip;
use Getopt::Long;
use Text::Wrap;
use POSIX qw/strftime/;

# Some sane defaults.
my $host = "localhost";
my $port = "6544";
my $description = undef;
my $episode = undef;
my $colour = undef;

my $VERSION = '0.5';

GetOptions(
  'c|colour|color' => \$colour,
  'd|descripton' => \$description,
  'e|episode'    => \$episode,
  'h|host=s'     => \$host,
  'p|port=s'     => \$port,
  'v|version'    => \&print_version,
);

die "Sorry, port isn't a number.\n"
  if $port !~ /^\d+$/;

my $safe = '';
my $warning = '';
my $normal = '';
if (defined $colour) {
  $safe    = "\033[0;32;40m";
  $warning = "\033[1;31;40m";
  $normal  = "\033[0m";
}

# Allow setting some defaults for the output blocks.
my %defaults = (
  'schedule' => {
    'attrs' => [ qw/title startTime NODE_TEXT subTitle/ ],
    'template' => "__startTime__ - __title__" 
      . (defined $episode ? " - __subTitle__" : '')
      . (defined $description ? "\n__NODE_TEXT__" : ''),
    'filter' =>  {
       # Only show recordings for today and tomorrow.
       'startTime' => sub {
         my $date = substr(ParseDate($_[0]), 0, 8);
         return ! (($date cmp $today) == 0
          || ($date cmp $tomorrow) == 0) }
     },
     'rewrite' => {
       '/startTime/' => { 'T' => ' ' },
     }
   }
);

my $next_time = undef;

# The blocks of output which we might generate.
my @blocks = (
  # Date/Time from server
  {
    'name'  => 'Status',
    'type'  => 'xpath',
    'xpath' => "//Status",
    'attrs' => [ qw/time date/ ],
    'template' => "__date__, __time__",
    'format' => 'one line'
  },

  # Info about the encoders.
  {
    'name'  => 'Encoders',
    'type'  => 'xpath',
    'xpath' => "//Status/Encoders/Encoder",
    'attrs' => [ qw/hostname id state connected/ ],
    'template' => "__hostname__ (__id__) - __state____connected__",
    'rewrite' => {
      '/connected/' => { '1' => '', '0' => ' (Disconnected)' },
      '/state/' =>{ '^0$' => "${safe}Idle${normal}",
                  '^1$' => "${warning}Watching LiveTV${normal}",
                  '^2$' => "${warning}Watching Pre-recorded${normal}",
		  '^3$' => "${warning}Watching Recording${normal}",
		  '^4$' => "${warning}Recording${normal}" },
    }
  },

  # What programs (if any) are being recorded right now?
  {
    'name'  => 'Recording Now',
    'type'  => 'xpath',
    'xpath' => "//Status/Encoders/Encoder/Program",
    'attrs' => [ qw/title endTime/ ],
    'template' => "__title__ (Ends: __endTime__)",
    'rewrite' => {
      '/endTime/' => { 'T' => ' ' },
     },
     'subs' => {
       'find_next' => sub { $next_time = 'now' }
     }
  },

  # The upcoming recordings.
  {
    'name'  => 'Scheduled Recordings',
    'type'  => 'xpath',
    'xpath' => '//Status/Scheduled/Program',
    'defaults' => 'schedule',
    'subs' => {
      'find_next' => sub {
	 my $vars = shift;
         return
	   if $next_time eq 'now';

         my $date = ParseDate($vars->{'startTime'});
	 if (! defined $next_time || Date_Cmp($date, $next_time) < 0) {
	   $next_time = $date
	 };
       }
     }
  },

  # Conflicts
  {
    'name' => 'Schedule Conflicts',
    'type' => 'Perl MythTV API',
    'defaults' => 'schedule',
  },

  # How many hours till the next recording.
  {
    'name' => 'Time till next recording',
    'type' => 'sub',
    'format' => 'one line',
    'template' => '__next_time__',
    'rewrite' => {
      '&next_time' => sub {
        return "Never"
	  unless defined $next_time;

        my $str = Delta_Format(DateCalc('now', $next_time, undef, 1), 0, '%hh Hours, %mv Minutes');
        $str =~ s/\b1 (Hour|Minute)s/1 $1/;
        $str =~ s/^0 Hours, //;
        $str =~ s/ 0 Minutes//;

	return $str;
      }
    },
    'filter' =>  {
      'next_time' => sub { return $_[0] eq 'now' }
    }
  },

);

###
### Fetch the XML status from the backend.
###
my $url = "http://$host:$port/xml";
my $status = get($url);

die "Sorry, failed to fetch $url.\n"
  unless defined $status;

###
### Parse the XML
###
my $parser = XML::LibXML->new();
my $xml = eval { $parser->parse_string( $status ) };

###
### Prep the Perl MythTV API if available.
###
my $myth = undef;
eval { use MythTV };
if (! $@) {
  eval { $myth = new MythTV() };
}

###
### Set some useful variables, and print the header
###
our $today    = substr(ParseDate('today'), 0, 8);
our $tomorrow = substr(ParseDate('tomorrow'), 0, 8);

my $title =  "MythTV status for $host";
print "\n$title\n";
print '=' x length($title) . "\n";

for my $block (@blocks) {
  $block->{'format'} ||= 'multi line';

  # We might need to set some defaults.
  if (defined $block->{'defaults'}) {
    for my $field (keys %{ $defaults{ $block->{'defaults'} } }) {
      $block->{$field} ||= $defaults{ $block->{'defaults'} }{$field};
    }
  }

  my $output = undef;
  if ($block->{'type'} eq 'xpath') {
    $output = process_xml($block, $xml);

  } elsif ($block->{'type'} eq 'Perl MythTV API') {
    $output = process_perl($block, $myth);

  } elsif ($block->{'type'} eq 'sub') {
    $output = substitute_vars($block, { 'next_time' => $next_time });
  }

  if (defined $output) {
    print "$block->{'name'}:" . ($block->{'format'} eq 'one line' ? ' ' : "\n");
    print $output . "\n\n";
  }
}

exit 0;

sub process_xml {
  my ($block, $xml) = @_;

  my $items = $xml->documentElement->find($block->{'xpath'});

  # Don't do any work on this block if there is nothing for it.
  return undef
    if (scalar(@$items) == 0);

  my @lines;
  for my $item (@{ $items }) {
    my %vars;
    for my $key (@{ $block->{'attrs'} }) {
      $vars{$key} = $key eq 'NODE_TEXT' ? $item->string_value : $item->getAttribute($key);
    }

    my $str = substitute_vars($block, \%vars);
    push @lines, $str
      if defined $str;
  }

  return join("\n", @lines);
}

sub process_perl {
  my ($block, $myth) = @_;

  return "Unable to access MythTV Perl API."
    unless defined $myth;

  my @lines;

  # This isn't defined in the 0.20 version of the API.  It is in 0.21svn.
  my $recstatus_conflict = 7;

  my %rows = $myth->backend_rows('QUERY_GETALLPENDING', 2);

  foreach my $row (@{$rows{'rows'}}) {
    my $show;
    {
      # MythTV::Program currently has a slightly broken line with a numeric
      # comparision.
      local($^W) = undef;
      $show = new MythTV::Program(@$row);
    }

    if ($show->{'recstatus'} == $recstatus_conflict) {
      my %vars = (
        'title'     => $show->{'title'},  
        'startTime' => strftime("%FT%T", localtime($show->{'starttime'})),
        'NODE_TEXT' => $show->{'description'},
        'subTitle'  => $show->{'subtitle'}
       );

      my $str = substitute_vars($block, \%vars);
      push @lines, $str
        if defined $str;
    }
  }

  return join("\n", @lines);
}

sub substitute_vars {
  my $block = shift;
  my $vars  = shift;

  my $template = $block->{'template'};
  my $skip = undef;
  my ($key, $value);
  while (($key, $value) = (each %{ $vars })) {
    $value = wrap('  ', '  ', $value)
      if $key eq 'NODE_TEXT';

    $value =~ s/\s+$//;
    $value = 'Unknown'
      if $value eq '';

    $skip = 1
      if defined $block->{'filter'}{$key} &&
        &{ $block->{'filter'}{$key} }($value);

    if (defined $block->{'rewrite'}{"/$key/"}) {
      my ($search, $replace);
      while (($search, $replace) = each %{ $block->{'rewrite'}{"/$key/"} } ) {
        $value =~ s/$search/$replace/g;
      }
    } elsif (defined $block->{'rewrite'}{"&$key"}) {
      $value = &{ $block->{'rewrite'}{"&$key"} }($value);
    }

    $template =~ s/__${key}__/$value/g;
  }

  my ($name, $sub);
  while (($name, $sub) =  each %{ $block->{'subs'} }) {
    &$sub($vars);
  }
   
  return defined $skip ? undef : $template;
}

sub print_version {
  print "mythtv-status, version $VERSION.\n";
  print "Written by Andrew Ruthven <andrew\@etc.gen.nz>\n";
  print "\n";
  exit;
}

=head1 NAME

mythtv-status - Display the status of a MythTV backend

=head1 SYNOPSIS

 mythtv-status [options]

=head1 DESCRIPTION

This script queries a MythTV backend and reports on the status of it,
any upcoming recordings and any which are happening right now.

The intention is to warn you if there is a program being recorded or
about to be recorded.

=head1 COMMAND LINE OPTIONS

=over

=item B<-c, --colour>

Use colour when showing the status of the encoder(s).

=item B<-d, --description>

Display the description for the scheduled recordings.

=item B<-e, --episode>

Display the episode (subtitle) for the scheduled recordings.

=item B<-h HOST, --host=HOST>

The host to check, defaults to localhost.

=item B<-p PORT, --port=PORT>

The port to use when connecting to MythTV, defaults to 6544.

=item B<-v, --version>

Show the version of mythtv-status and then exit.

=back

=head1 OUTPUT

The output of this script is broken up into several chunks they are:

=over

=item Status

Some general info about the backend, currently just the timestamp of when
this program was run.

=item Encoders

Each encoder that the backend knows about are listed, with the hostname
they are on, the encoder ID (in brackets) and the current status.

=item Recording Now

Any programs which are being recorded right now.

=item Scheduled Recordings

Up to 10 programs which are scheduled to be recorded today and tomorrow.

=item Schedule Conflicts

Any upcoming schedule conflicts (not just limited to today or tomorrow).

=item Time till next recording

If there are no recordings currently happening, then the amount of time until
the next recording is displayed.

=back

=head1 AUTHOR

Andrew Ruthven, andrew@etc.gen.nz

=head1 LICENSE

Copyright (c) 2007 Andrew Ruthven <andrew@etc.gen.nz>
This code is hereby licensed for public consumption under the GNU GPL v2.

=cut

