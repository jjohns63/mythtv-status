#!/usr/bin/perl -w
# Copyright (c) 2007 Andrew Ruthven <andrew@etc.gen.nz>
# This code is hereby licensed for public consumption under the GNU GPL v2.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# Display the current status of a MythTV system.

use LWP::Simple;
use XML::LibXML;
use Date::Manip;
use Getopt::Long;
use Text::Wrap;
use POSIX qw/strftime/;
use MIME::Entity;
use Pod::Usage;

# Some sane defaults.
my $host = "localhost";
my $port = "6544";
my $description = undef;
my $episode = undef;
my $colour = undef;
my %display;
my @email;
my $email_only_on_conflict = 0;
my $help = undef;
my $xml_file = undef;
my $verbose = 0;

my $VERSION = '0.5.1';

GetOptions(
  'c|colour|color' => \$colour,
  'd|descripton' => \$description,
  'e|episode'    => \$episode,
  'h|host=s'     => \$host,
  'p|port=s'     => \$port,
  'v|version'    => \&print_version,
  'email=s@'     => \@email,
  'email-only-on-conflict' => \$email_only_on_conflict,
  'status!'               => \$display{'Status'},
  'encoders!'             => \$display{'Encoders'},
  'recording-now!'        => \$display{'Recording Now'},
  'scheduled-recordings!' => \$display{'Scheduled Recordings'},
  'schedule-conflicts!'   => \$display{'Schedule Conflicts'},
  'next-recording!'       => \$display{'Time till next recording'},

  'file=s'                => \$xml_file,

  'verbose' => \$verbose,
  'help|?' => \$help,
) || pod2usage("\nUse --help for help.\n");

pod2usage(verbose => 1)
  if defined $help;

die "Sorry, port isn't a number.\n"
  if $port !~ /^\d+$/;

# Get the email address into a format we can use.
@email = split(',', join(',', @email));

# Default to not showing some blocks if we're sending email, but let the
# user override us.
if (scalar(@email) > 0) {
  for my $block ('Encoders', 'Recording Now', 'Time till next recording') {
    if (! defined $display{$block}) {
      $display{$block} = 0;
    }
  }
}

# Possibly use some colour, but not in emails.
my $safe = '';
my $warning = '';
my $normal = '';
if (defined $colour && scalar(@email) == 0) {
  $safe    = "\033[0;32m";
  $warning = "\033[1;31m";
  $normal  = "\033[0m";
}

# Allow setting some defaults for the output blocks.
my %defaults = (
  'schedule' => {
    'attrs' => [ qw/title startTime NODE_TEXT subTitle/ ],
    'template' => "__startTime__ - __title__" 
      . (defined $episode ? " - __subTitle__" : '')
      . (defined $description ? "\n__NODE_TEXT__" : ''),
    'filter' =>  {
       # Only show recordings for today and tomorrow.
       'startTime' => sub {
         my $date = substr(ParseDate($_[0]), 0, 8);
         return ! (($date cmp $today) == 0
          || ($date cmp $tomorrow) == 0) }
     },
     'rewrite' => {
       '/startTime/' => { 'T' => ' ' },
     }
   }
);

my $next_time = 'Never';

# The blocks of output which we might generate.
my @blocks = (
  # Date/Time from server
  {
    'name'  => 'Status',
    'type'  => 'xpath',
    'xpath' => "//Status",
    'attrs' => [ qw/time date/ ],
    'template' => "__date__, __time__",
    'format' => 'one line'
  },

  # Info about the encoders.
  {
    'name'  => 'Encoders',
    'type'  => 'xpath',
    'xpath' => "//Status/Encoders/Encoder",
    'attrs' => [ qw/hostname id state connected/ ],
    'template' => "__hostname__ (__id__) - __state____connected__",
    'rewrite' => {
      '/connected/' => { '1' => '', '0' => ' (Disconnected)' },
      '/state/' =>{ '^0$' => "${safe}Idle${normal}",
                  '^1$' => "${warning}Watching LiveTV${normal}",
                  '^2$' => "${warning}Watching Pre-recorded${normal}",
		  '^3$' => "${warning}Watching Recording${normal}",
		  '^4$' => "${warning}Recording${normal}" },
    }
  },

  # What programs (if any) are being recorded right now?
  {
    'name'  => 'Recording Now',
    'type'  => 'xpath',
    'xpath' => "//Status/Encoders/Encoder/Program",
    'hide'  => 'after',
    'attrs' => [ qw/title endTime/ ],
    'template' => "__title__ (Ends: __endTime__)",
    'rewrite' => {
      '/endTime/' => { '.*T' => '' },
     },
     'subs' => {
       'find_next' => sub { $next_time = 'now' }
     }
  },

  # The upcoming recordings.
  {
    'name'  => 'Scheduled Recordings',
    'type'  => 'xpath',
    'xpath' => '//Status/Scheduled/Program',
    'defaults' => 'schedule',
    'hide'  => 'after',
    'subs' => {
      'find_next' => sub {
	 my $vars = shift;
         return
	   if defined $next_time && $next_time eq 'now';

         my $date = ParseDate($vars->{'startTime'});
	 if ($next_time eq 'Never' || Date_Cmp($date, $next_time) < 0) {
	   $next_time = $date
	 };
       }
     }
  },

  # Conflicts
  {
    'name' => 'Schedule Conflicts',
    'type' => 'sub',
    'defaults' => 'schedule',
    'sub' => \&process_conflicts
  },

  # How many hours till the next recording.
  {
    'name' => 'Time till next recording',
    'type' => 'sub',
    'format' => 'one line',
    'template' => '__next_time__',
    'rewrite' => {
      '&next_time' => sub {
	return $next_time
	  if $next_time eq 'Never' || $next_time eq 'now';

        my $str = Delta_Format(DateCalc('now', $next_time, undef, 1), 0, '%hh Hours, %mv Minutes');
        $str =~ s/\b1 (Hour|Minute)s/1 $1/;
        $str =~ s/^0 Hours, (.*)$/$warning$1$normal/;
        $str =~ s/ 0 Minutes//;

	return $str;
      }
    },
    'filter' =>  {
      'next_time' => sub { return $_[0] eq 'now' }
    },
    'sub' => sub {
      return substitute_vars($_[0], { 'next_time' => $next_time });
    }
  },

);

###
### Set some useful variables
###
our $today    = substr(ParseDate('today'), 0, 8);
our $tomorrow = substr(ParseDate('tomorrow'), 0, 8);

# A couple of global variables
my ($xml, $myth);
my $schedule_conflicts_present = 0;

my $title =  "MythTV status for $host";
my $output = "$title\n";
$output .= '=' x length($title) . "\n";

for my $block (@blocks) {
  $block->{'format'} ||= 'multi line';

  my $hide = undef;
  if (defined $display{ $block->{'name'} }
    && $display{ $block->{'name'} } == 0) {
    if (defined $block->{'hide'} && lc($block->{'hide'}) eq 'after') {
      $hide = 1;
    } else {
      next;
    }
  }

  # We might need to set some defaults.
  if (defined $block->{'defaults'}) {
    for my $field (keys %{ $defaults{ $block->{'defaults'} } }) {
      $block->{$field} ||= $defaults{ $block->{'defaults'} }{$field};
    }
  }

  my $result = undef;
  if ($block->{'type'} eq 'xpath') {
    $xml ||= load_xml();

    $result = process_xml($block, $xml);

  } elsif ($block->{'type'} eq 'sub') {

    $result = &{ $block->{'sub'} }($block)
      if defined $block->{'sub'};
  }

  if (defined $result && $result ne '' && ! defined $hide) {
    $output .= "$block->{'name'}:" . ($block->{'format'} eq 'one line' ? ' ' : "\n");
    $output .= $result . "\n\n";
  }
}

# Either print the status out, or email it.
if (scalar(@email) == 0) {
  print "\n$output";
} else {
  if (! ($email_only_on_conflict && ! $schedule_conflicts_present)) {
    my $mail = MIME::Entity->build(
      To      => \@email,
      Subject => $title . ($schedule_conflicts_present ? ' - CONFLICTS' : ''),
      Data    => $output
    ); 

    $mail->send('sendmail');
  }
}

exit 0;

# Fetch the XML status from the backend.
sub load_xml {
  my $status = "";

  if (defined $xml_file) {
    open (IN, "< $xml_file")
      || die "Failed to open $xml_file for reading: $!\n";

    $status = join("", <IN>);

    close IN;
  } else {
    my $url = "http://$host:$port/xml";
    $status = get($url);

    die "Sorry, failed to fetch $url.\n"
      unless defined $status;
  }

  # Parse the XML
  my $parser = XML::LibXML->new();

  # Some XML data seems to have badness in it, including non-existant
  # UTF-8 characters.  We'll try and recover.
  $parser->recover(1);
  $parser->recover_silently(1)
    unless $verbose;

  clean_xml(\$status);

  my $xml = eval { $parser->parse_string( $status ) };

  if ($@) {
    die "Failed to parse XML: $@\n";
  }

  return $xml;
}


# Prep the Perl MythTV API if available.
sub load_perl_api {
  my $myth = undef;

  eval { require MythTV };
  if (! $@) {
    eval { $myth = new MythTV() };
  }

  return $myth;
}

# We are sometimes passed dodgy XML from MythTV, make some attempts to clean
# it.
sub clean_xml {
  my ($xml) = shift;

  # Deal to invalid Unicode.
  for my $bad ("&#xdbff;", "&#xdee9;") {
    if ($$xml =~ s/$bad/?/g) {
      warn "Found and replaced: $bad\n"
        if $verbose;
    }
  }
}

sub process_xml {
  my ($block, $xml) = @_;

  my $items = $xml->documentElement->find($block->{'xpath'});

  # Don't do any work on this block if there is nothing for it.
  return undef
    if (scalar(@$items) == 0);

  my @lines;
  for my $item (@{ $items }) {
    my %vars;
    for my $key (@{ $block->{'attrs'} }) {
      $vars{$key} = $key eq 'NODE_TEXT' ? $item->string_value : $item->getAttribute($key);
    }

    my $str = substitute_vars($block, \%vars);
    push @lines, $str
      if defined $str;
  }

  return join("\n", @lines);
}

sub process_conflicts {
  my ($block) = @_;
  $myth ||= load_perl_api();

  return "Unable to access MythTV Perl API."
    unless defined $myth;

  my @lines;

  # This isn't defined in the 0.20 version of the API.  It is in 0.21svn.
  my $recstatus_conflict = 7;

  my %rows = $myth->backend_rows('QUERY_GETALLPENDING', 2);

  foreach my $row (@{$rows{'rows'}}) {
    my $show;
    {
      # MythTV::Program currently has a slightly broken line with a numeric
      # comparision.
      local($^W) = undef;
      $show = new MythTV::Program(@$row);
    }

    if ($show->{'recstatus'} == $recstatus_conflict) {
      my %vars = (
        'title'     => $show->{'title'},  
        'startTime' => strftime("%FT%T", localtime($show->{'starttime'})),
        'NODE_TEXT' => $show->{'description'},
        'subTitle'  => $show->{'subtitle'}
       );

      my $str = substitute_vars($block, \%vars);
      push @lines, $str
        if defined $str;
    }
  }

  $schedule_conflicts_present = scalar(@lines);

  return join("\n", @lines);
}

sub substitute_vars {
  my $block = shift;
  my $vars  = shift;

  my $template = $block->{'template'};
  my $skip = undef;
  my ($key, $value);
  while (($key, $value) = (each %{ $vars })) {
    if (! defined $value) {
      warn "Unable to find any value for $key while looking at $block->{'name'}\n";
      next;
    }

    $value = wrap('  ', '  ', $value)
      if $key eq 'NODE_TEXT';

    $value =~ s/\s+$//;
    $value = 'Unknown'
      if $value eq '';

    $skip = 1
      if defined $block->{'filter'}{$key} &&
        &{ $block->{'filter'}{$key} }($value);

    if (defined $block->{'rewrite'}{"/$key/"}) {
      my ($search, $replace);
      while (($search, $replace) = each %{ $block->{'rewrite'}{"/$key/"} } ) {
        $value =~ s/$search/$replace/g;
      }
    } elsif (defined $block->{'rewrite'}{"&$key"}) {
      $value = &{ $block->{'rewrite'}{"&$key"} }($value);
    }

    $template =~ s/__${key}__/$value/g;
  }

  my ($name, $sub);
  while (($name, $sub) =  each %{ $block->{'subs'} }) {
    &$sub($vars);
  }
   
  return defined $skip ? undef : $template;
}

sub print_version {
  print "mythtv-status, version $VERSION.\n";
  print "Written by Andrew Ruthven <andrew\@etc.gen.nz>\n";
  print "\n";
  exit;
}

=head1 NAME

mythtv-status - Display the status of a MythTV backend

=head1 SYNOPSIS

 mythtv-status [options]

=head1 DESCRIPTION

This script queries a MythTV backend and reports on the status of it,
any upcoming recordings and any which are happening right now.

The intention is to warn you if there is a program being recorded or
about to be recorded.

=head1 OPTIONS

=over

=item B<-c, --colour>

Use colour when showing the status of the encoder(s).

=item B<-d, --description>

Display the description for the scheduled recordings.

=item B<-e, --episode>

Display the episode (subtitle) for the scheduled recordings.

=item B<< --email <address>[ --email <address> ...] >>

Send the output to the listed email addresses.  By default the encoder status,
currently recording shows and time till next recording is surpressed from
the email.

To turn the additional blocks on you can use B<--encoders>, B<--recording-now>
and/or B<--next-recording>.

=item B<--email-only-on-conflict>

Only send an email out (if --email is present) if there is a schedule conflict.

=item B<-?, --help>

Display help.

=item B<< --file <file> >>

Load XML from the file specified instead of querying a MythTV backend.
Handy for debugging things.

=item B<-h HOST, --host=HOST>

The host to check, defaults to localhost.

=item B<--nostatus>, B<--noencoders>, B<--norecording-now>, B<--noscheduled-recordings>, B<--noschedule-conflicts>, B<--nonext-recording>

Suppress displaying blocks of the output if they would normally be displayed.

=item B<-p PORT, --port=PORT>

The port to use when connecting to MythTV, defaults to 6544.

=item B<--verbose>

Have slightly more verbose output.  This includes any warnings that might
be generated while parsing the XML.

=item B<-v, --version>

Show the version of mythtv-status and then exit.

=back

=head1 OUTPUT

The output of this script is broken up into several chunks they are:

=over

=item Status

Some general info about the backend, currently just the timestamp of when
this program was run.

=item Encoders

Each encoder that the backend knows about are listed, with the hostname
they are on, the encoder ID (in brackets) and the current status.

=item Recording Now

Any programs which are being recorded right now.

=item Scheduled Recordings

Up to 10 programs which are scheduled to be recorded today and tomorrow.

=item Schedule Conflicts

Any upcoming schedule conflicts (not just limited to today or tomorrow).

=item Time till next recording

If there are no recordings currently happening, then the amount of time until
the next recording is displayed.

=back

=head1 AUTHOR

Andrew Ruthven, andrew@etc.gen.nz

=head1 LICENSE

Copyright (c) 2007 Andrew Ruthven <andrew@etc.gen.nz>
This code is hereby licensed for public consumption under the GNU GPL v2.

=cut

